# Algorithm

getline(cin, s); : 문자열 한줄 전체 입력 받는 함수  
cin.eof() : End of File

s[i] >= 97 && s[i] <= 122 알파벳 소문자  
s[i] >= 65 && s[i] <= 90 알파벳 대문자

char 형의 경우 128을 넘어갈 때 overflow가 발생함

str1.compare(str2)

- str1이 str2보다 사전적으로 앞서 있으면 0보다 작고
- str1과 str2이 같을 경우 0
- str1이 str2보다 사전적으로 뒤에 있으면 0보다 크다

최대 공약수(GCD)

- a를 b로 나눈 나머지를 r이라고 했을 때
- GCD(a, b) = GCD(b, r)
- r이 0 이면 그 때 b가 최대 공약수이다.
- GCD(24, 16) = GCD(16, 8) = GCD(8, 0) = 8

최소 공배수(LCM)

- 최소공배수는 GCD를 응용해서 구할 수 있다.
- a, b의 최대 공약수를 g라고 했을 때
- 최소공배수 l = g \* (a/g) \* (b/g)

소수

- N이 소수가 되려면, 2보다 크거나 같고 N-1보다 작거나 같은 자연수로 나누어 떨어지면 안된다.
- N이 소수가 되려면, 2보다 크거나 같고, N/2보다 작거나 같은 자연수로 나누어 떨어지면 안된다.(N의 약수 중에서 가장 큰 것은 N/2보다 작거나 같기 때문)
- N이 소수가 되려면, 2보다 크거나 같고, 루트 N보다 작거나 같은 자연수로 나누어 떨어지면 안된다.(N이 소수가 아니라면 N = a X b로 나타낼 수 있다.(a <= b))

에라토스테네스의 체

1. 2 부터 N까지 모든 수를 써놓는다.
2. 아직 지워지지 않은 수 중에서 가장 작은 수를 찾는다.
3. 그 수는 소수이다.
4. 이제 그 수의 배수를 모두 지운다.

## 그래프

### 인접행렬

- 정점의 개수를 V라고 했을 때 V X V 크기의 이차원 배열을 이용
- A[i][j] = 1(i -> j 간선이 있을 때), 0 (없을 때)
- 가중치가 있는 경우 A[i][j] = w (w 간선의 가중치), 0(없을 때)

### 인접 리스트

- 링크드 리스트를 이용해서 구현
- A[i] = i와 연결된 정점을 리스트로 포함하고 있음.
- A[1] = 2, 5 -> 1번 정점와 2, 5번 정점이 연결되어 있음
- 가중치가 있는 경우 A[i] = (2,w1) (5, w2) 정점과 가중치의 튜플형태로 저장

### 간선 리스트

- 배열을 이용해서 간선을 모두 저장
- E[0] = 1 2 (1번 정점과 2번 정점을 잇는 간선)
- cnt[i] : i번째 정점까지의 간선의 개수 -> E배열의 인덱스 역활을 한다.
- i번 정점과 연결된 간선은 E 배열에서 cnt[i-1] ~ cnt[i] - 1 인데스에 저장되어 있음
- 자세한 것은 강의자료 참고

### 깊이 우선 탐색

- 스택을 이용
- 갈 수 없으면 이전 정점으로 돌아간다.

### 너비 우선 탐색

- 큐를 이용
- 지금 위치에서 갈 수 있는 것을 모두 큐에 넣는 방식
- 큐에 넣을 때 방문했다고 체크해야 한다.
